## NextJS

- next-js 관련한 기능들을 살펴본다


- 라우팅, 페이징, 컴포넌트 같은 일반적인 개념 등등...

---

- page.js 는 NextJS 에게 해당 페이지를 렌더링해야한다고 알려주는 역할을 한다 
  - page.js 컴포넌트의 특징은 서버컴포넌트라는 것이다


- 즉, page.js 컴포넌트가 서버에서 렌더링되고, 실행되는것을 보장한다
  - ( 로그를 찍어보면, 서버쪽 터미널에서 찍힌다 )


- 파일기반 라우팅이기 때문에, 파일명을 통해 Next.js 에 페이지를 만든다고 전달한다
````
app/                    # 해당 App 디렉터리 안에 필요한 페이지를 추가해 파일라우팅 할 수 있다 
|
|– about/               # 새로운 페이지 생성
|     |– page.js        # page.js 를 정의해야 새로운 페이지를 렌더링할 수 있다
|     |– layout.js      # 해당 페이지의 레이아웃을 정의할 수 있다
|     |– not-fount.js   # notFound 페이지 정의
|     |– error.js       # error 페이지 정의
````

- a 태그를 통해 이동하게 되면, 더이상 SPA 가 아니라는 뜻이된다( 서버에서 html 을 받아오므로 )
  - 물론, NextJS 의 경우에는, SSR 을 이용하기 때문에, 
  - 내용이 Back-end 에서 렌더링되어서, 렌더링이 클라이언트에서 발생하지 않는다는것이다
  - 그러나, 해당페이지에 접속한 이후, 라우팅이동을 클릭하게되면, 클라이언트 측 코드로 라우팅을 하게된다
  - ( 내용물은 서버에서 전달해주기에, 렌더링하기전이지만, 클라이언트 코드로 클라이언트 사이드에 업데이트 된다 )


- 즉, SPA 처럼 라우팅을하고, 서버에서 해당 페이지의 content 를 받아오려면, a 태그를 통해 이동하면 안된다
  - next 에서 제공하는 Link 를 이용해야 한다

---
### layout

- 모든 Next.js 프로젝트에는 하나이상의 layout 파일이 필요하다.
- 즉, app 폴더 전체를 위해 layout.js 파일이 하나는 존재해야 한다
  - 중첩된 layout.js 파일도 존재 가능하다
  - 해당 디렉터리에 정의된 layout 파일은 해당 디렉터리안의 중첩된 모든 디렉터리안에만 유효하다


- 그러나, 반드시 RootLayout 파일은 필요하다


- 또한, Next.JS 에서는 직접 head 를 설정하는 대신에
- metadata 라는 상수를 통해, <head></head> 태그안에 들어가는 <title>, <description> 등의 태그를 정의할 수 있다


- 그리고, icon 이라는 파일명을 넣으면, NextJS 에서 해당 icon 을 favicon 으로 대체하여 사용하도록 한다

---

### page

- app 디렉터리 안에 page.js 같은 파일명을 추가하게 되면 해당 디렉터리는 라우트로 인식되게 된다


- 또한, layout.js 를 추가하게 되면, 해당 라우트의 layout 으로 자동인식하게 된다


- Dynamic Route 를 이용하여, 동적으로 생성되는 페이지( 게시물 )등을 관리할 수 있다
  - Dynamic Route 는 []를 작성하고, 안에 식별자를 추가함으로써 생성할 수 있다
  - 해당 Route 의 [] 안의 식별서값은 props 의 params 안에 해당 식별자 이름으로 담겨있다
  - ( 예 : posts/[ slug ] ) --> props.params.slug


---

### Image

- Next 에서 image 를 import 하여 내부 경로로 참조하게 할때는,
  - 일반적으로, 해당 객체의 src 프로퍼티에 해당 이미지의 경로가 참조되어 들어가게 된다

- 그러나 Next.js 에서는 특별히 내부에 렌더링하기위해 제공하는 Image 내장 요소가 존재한다
  - 이것은 더 최적화된 방식으로 이미지를 출력할 수 있도록 도와준다 
  - 예) LazyLoading 기법등...!


- 따라서, Next.js 에서 이미지를 출력하게 된다면 Next 에 내장된 <Image/> 컴포넌트를 사용하는 것이 좋다
  - 해당 컴포넌트는 image 를 import 시 src 를 넘겨주는 것이 아니라, image 객체 자체를 <Image src= /> 값으로 넘겨준다


- Next 의 Image 컴포넌트에서는 image 를 최적화된 방식으로 불러오는, 다양한 기법들을 사용한다
  - 이미지를 불러오는 방식을 최적화해주고, 접속하는 기기, 브라우저별로도 최적화해준다
  - ( png 로 저장했는데 webp 로 불러오는거 보고 놀랐음...! )

---

- next.js 에서는 서버 컴포넌트 뿐만아니라, 클라이언트에서 동작하는 컴포넌트도 만들 수 있다


- client 컴포넌트를 만들고 싶다면, 해당 컴포넌트 파일 위에 'use client' 지시어를 사용해야 한다


- 서버 컴포넌트의 상태를 잃지 않게 하기 위해서는, 컴포넌트 트리의 최대한 하위에서 'use client' 지시어를 추가해 주는게 좋다


- NextJS 에서 데이터를 로딩하는것은 몇가지 선택권이 존재한다


- NextJS 는 보이지않는곳에서 굉장히 공격적으로 캐싱정책을 사용하고 있다
  - 방문했던 모든 페이지들을 캐싱한다
  - 따라서, 해당 Domain 을 떠났다가 다시 돌아올때만, 다시 페이지를 불러온다


- loading.js 를 이용하면, Next 자체에서 페이지 loading 기능을 이용하도록 해준다
  - Next JS 는 states( 상태 )를 로딩하는 다른 방법도 제공하며 조금 더 세분화된 방법이다
  - Suspense 방법인데 loading 파일도 Next 에서 사실 Suspense 로 감싼 파일이다


- 또한 error 처리를 위한 error.js 를 추가한다
  - 해당 error 객체는 중첩된 해당 페이지 라우팅의 Error 만 처리하게 된다
  - error 컴포넌트는 반드시 client 컴포넌트 형태여야 한다

---

### use server

- next 에서는 client 에서만 실행되는 컴포넌트들에는 use client 키워드를 사용한다


- 반대로, server 에서 사용할 수 있도록 하는 함수들에는 use server 키워드를 등록하여, server 에서 동작하도록 할 수 있다


- 또한, 해당 지시어는 client component 에서는 use server 키워드를 사용할 수 없다


- 따라서, 보통 server 에서 곧바로 사용하는 기능들은 actions 파일로 분리해야 'use client' 를 사용한 파일에서도 사용할 수 있다 
  - 서버측 코드가 클라이언트 코드등에 섞이는 등의 이슈를 해결하기위해...!


- 보통 next 에서 DB 에 저장할때, 직접 저장하는것이 아니라, slugify 를 이용하여 저장한다


- 파일들은 보통 db 에 저장하기 적합하지 않다( 파일시스템에 저장해야하기 때문에 )
  - 여기에서는 public 폴더에 저장한다


- next 서버에서 반환하는 응답에는 직렬화 가능한 객체를 전달해야한다
  - ( 메서드등을 추가하여 반환하면 안된다 )

---


- next 에서 npm run build 를 하게되면, 생성할 수 있는 페이지들을 사전생성하기 때문에,
  - 기본적으로는 동적 웹페이지가 아니게 된다
  - 즉, 웹을 방문하는 첫 사용자부터 렌더링을 기다릴 필요없이 즉시 생성되게 한다
  - 그후, NextJS 는 사전 렌더링된 페이지들을 캐싱하여 모든 방문자에게 제공할 수 있게한다


- 단점으로는, 목록을 다시갱신하지 않고, 사전 생성된 페이지를 불러오기 때문에, 목록에 업데이트하여도 기존의 데이터를 반환한다
  - ( 재요청하는것이 아닌, 빌드할때, 서버에서 불러와서 데이터를 html 에 그려버리네... )
  - Next 가 공격적인 캐싱을 사용해서 그렇다


- 따라서, next 에게 새로운 데이터를 등록할때마다, 캐시의 전체나 일부를 비우라고 해야한다
  - revalidatePath( '/path' , 'page' || 'layout' ) 메서드를 이용하여, 
  - action 으로 인해 동적으로 값이 변할경우, 다시 validation 검사를 수행하라고 해야한다
  - 그런데 해당 path 만 validation 검사를 다시수행하므로, 전체 page 의 validation 검사를 다시 수행하지 않는다
  - 2 번째 파라미터로 layout( default : page )  을 전달하면, layout 중첩된 페이지를 검사한다( 전체 layout 에 validation 체크하므로 )

### file save

- 파일 저장시에는 AWS S3 파일저장시스템을 이용하는것이 좋다
  - ( 로컬 저장시 배포이슈가 존재한다 )

---

### metadata

- layout 에 metadata 를 추가하게 되면, 해당 layout 이 감싸고 있는 모든 페이지에 자동으로 적용된다
  - 만약, page 에 metadata 가 존재한다면, page metadata 가 우선 적용된다
  - ( 중첩된 layout 도 마찬가지 )


- 또한, 동적 MetaData 는 이렇게 설정할 수 없다


- 동적 페이지의 경우에는 generateMedata 라는 async 함수를 export 하여 메타데이터를 등록할 수 있다
  - 예( 동적 페이지인 : [ mealSlug ] 페이지 )

--- 

### 정리

- App Route 방식


- error.js , not-found.js 등 


- useEffect 를 사용하지 않고, 서버 컴포넌트내에서 직접 데이터를 가져올 수 있다
  - 요청을 따로, backend 에 보내지 않고 그저 서버 컴포넌트안에서 바로 데이터를 가져올 수 있다


- 또한, server actions 함수는 'use server' 지시어를 사용해 분리해 사용할 수 있다


- server action 은 form 요소의 action 속성에 할당할 수 있다
  - useFormState , useFormStatus 등을 활용하여 server action 이 응답하는 값으로 상태를 처리할 수 있다


- 또한 next 는 공격적인 캐싱을 하기 때문에 revalidatePath 를 사용한다


- 또한, public 폴더에 자산을 저장한다면, 배포환경에서는 위험가능성이 높다
  - 따라서 AWS S3 에 데이터를 저장한다


- 마지막으로 동적인 metadata 를 사용한다면, generateMetadata 를 사용하여 동적인 페이지에 metadata 를 적용할 수 있다